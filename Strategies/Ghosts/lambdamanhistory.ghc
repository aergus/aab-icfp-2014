; check if lambdaman is at a crossing
DEF his_start 128
DEFENUM his_cur
DEFENUM not_init
DEFENUM his_dir
jeq init, [not_init],0

jeq history_dir, [his_dir],1

history:
        int 1
        mov [neighbours_in_x], a
        mov [neighbours_in_y], b
        mov [neighbours_rt], history_return
        mov pc,neighbours
history_return:
        ; check if it is a crossing
        jlt hand, [neighbours_out],3
        ; It is a crossing
        ; check if it is the same as the last one
        mov a,[neighbours_rt]
        sub a,2
        jeq history_x, [a],[neighbours_in_x]
        mov pc, history_new
history_x:
        inc a
        jeq history_dup, [a],[neighbours_in_y]
history_new:
        mov [his_cur], [neighbours_in_x]
        inc [his_cur]
        mov [his_cur], [neighbours_in_y]
        inc [his_cur]
history_wantdir:
        mov [his_dir],1
        mov pc,hand

history_dup:
        ; update only direction
        add [his_cur],2
        mov pc,history_wantdir 
         
history_dir:
return:
        hlt

; hand rule
; in 
DEFENUM hand_in ;1 for left, -1 for right
; init [neighbours_in_x], [neighbours_in_y]
hand:
        ; get our coordinates in a and b
        int 3
        int 5
        ; save them in neighbours_in_x etc.
        mov [neighbours_in_x], a
        mov [neighbours_in_y], b
        mov [neighbours_rt],hand_return
        mov pc,neighbours
hand_return:
        ; save if it is a crossing
        ; also direction (which is in b)
        int 3
        int 6
        ; b now contains my current orientation
        xor b,2 ; reverse b
        mov a,b
        mov c,[hand_in]
        mul c,2
hand_loop:
        add a,[hand_in]
        sub c,[hand_in]
        and a,3 ; poor man's % 4
        jeq hand_loop, [a],0 ; a wand? then try next direction
        ; otherwise set direction
        int 0
        hlt

init:
        mov [not_init],1
        mov [hand_in],1
        mov [his_cur], his_start
        mov pc, history

; in ([neighbours_in_x], [neighbours_in_y]) coordinate pair
; doesn't change neighbours_in_x and neighbours_in_y
DEFENUM neighbours_in_x
DEFENUM neighbours_in_y
;uses
; a b c e f 
DEFENUM neighbours_x
DEFENUM neighbours_y
DEFENUM neighbours_counter ; as a counter
; out 
; [0] .. [3] contain the map information in this direction
DEFENUM neighbours_out ; number of neighbours
; jumps back to
DEFENUM neighbours_rt

neighbours:
        ; set e f h for offset
        mov e,neighbours_x
        mov f,neighbours_y
        mov [offset_rt],neighbours_offreturn
        mov c,offup
        mov [neighbours_out],0
        mov [neighbours_counter],255
neighbours_loop:
        inc [neighbours_counter]
        mov [neighbours_x],[neighbours_in_x]
        mov [neighbours_y],[neighbours_in_y]
        mov pc,c
neighbours_offreturn:
        add c,2
        mov a,[neighbours_x]
        mov b,[neighbours_y]
        int 7
        mov b,[neighbours_counter]
        mov [b],a
        jeq neighbours_end, a, 0
        inc [neighbours_out]
neighbours_end:
        jlt neighbours_loop, [neighbours_counter], 3
        mov pc,[neighbours_rt]
; offset
; in c direction
;    h return
; out add to [e] and [f] offset 
; keeps e,f,h const
; jumps to
DEFENUM offset_rt
; tains c

offset:
mul c,2
add c,offup
mov pc,c
offup:
        dec [f] ; go up
        mov pc,[offset_rt]
offright:
        inc [e] ; go right
        mov pc,[offset_rt]
offdown:
        inc [f] ; go down
        mov pc,[offset_rt]
offleft:
        dec [e] ; go left
        mov pc,[offset_rt]
offend:
        hlt

comparecoordinates:
        mov c,a
        mov d,b
        ; Get lambda-man's coordinates
        ; Which difference is bigger?
        mov e,a
        sub e,c
        mul e,e ; e = dx^2
        mov f,b
        sub f,d
        mul f,f ; f = dy^2
        JLT ydiv,e,f
xdiv:
        JGT right, a,c
left:
        mov a,3
        mov pc,return
right:
        mov a,1
        mov pc,return
ydiv:
        JGT down, b,d
up:
        mov a,0
        mov pc,return
down:
        mov a,2
        mov pc,return
